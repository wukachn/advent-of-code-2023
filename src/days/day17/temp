
const shortestPath = (map: number[][], currentPoint: Point, dir: Direction, route: RoutePoint[], memo: Map<string, number>): number => {
    if (visitedNodeWithDirection(route, currentPoint, dir)) {
        return Infinity
    }
    const memoKey = `${currentPoint.line}-${currentPoint.column}-${dir}`
    const memoRes = memo.get(memoKey)
    if (memoRes) {
        return memoRes
    }

    if (currentPoint.column === map[0].length - 1 && currentPoint.line === map.length - 1) {
        return getPointValue(map, currentPoint) // maybe return final cell value
    }

    let pointValue: number = getPointValue(map, currentPoint)
    if (pointValue === Infinity) {
        return Infinity
    }

    const straightValues: number[] = [pointValue]
    let [left1, right1] = getLeftRight(currentPoint, dir)
    route.push({ point: currentPoint, dir: dir })
    const oneStep: number = Math.min(straightValues[0] + getPointValue(map, left1.point) + shortestPath(map, left1.point, left1.dir, [...route], memo),
        straightValues[0] + getPointValue(map, right1.point) + shortestPath(map, right1.point, right1.dir, [...route], memo))

    let nextPoint: Point = incrementPoint(currentPoint, dir)
    pointValue = getPointValue(map, nextPoint)
    if (pointValue === Infinity) {
        return oneStep
    }
    straightValues.push(pointValue)
    let [left2, right2] = getLeftRight(nextPoint, dir)
    route.push({ point: nextPoint, dir: dir })
    const twoStep: number = Math.min(straightValues[0] + straightValues[1] + getPointValue(map, left2.point) + shortestPath(map, left2.point, left2.dir, [...route], memo),
        straightValues[0] + straightValues[1] + getPointValue(map, right2.point) + shortestPath(map, right2.point, right2.dir, [...route], memo))

    nextPoint = incrementPoint(nextPoint, dir)
    pointValue = getPointValue(map, nextPoint)
    if (pointValue === Infinity) {
        return Math.min(oneStep, twoStep)
    }
    straightValues.push(pointValue)
    let [left3, right3] = getLeftRight(nextPoint, dir)
    route.push({ point: nextPoint, dir: dir })
    const threeStep: number = Math.min(straightValues[0] + straightValues[1] + straightValues[2] + getPointValue(map, left3.point) + shortestPath(map, left3.point, left3.dir, [...route], memo),
        straightValues[0] + straightValues[1] + straightValues[2] + getPointValue(map, right3.point) + shortestPath(map, right3.point, right3.dir, [...route], memo))

    return Math.min(oneStep, twoStep, threeStep)
}

const visitedNodeWithDirection = (route: RoutePoint[], currentPoint: Point, dir: Direction) => {
    return !!route.find(routePoint => routePoint.dir === dir && routePoint.point.line === currentPoint.line && routePoint.point.column === currentPoint.column)
}

const incrementPoint = (point: Point, dir: Direction): Point => {
    switch (dir) {
        case Direction.North:
            return { line: point.line - 1, column: point.column }
        case Direction.East:
            return { line: point.line, column: point.column + 1 }
        case Direction.South:
            return { line: point.line + 1, column: point.column }
        case Direction.West:
            return { line: point.line, column: point.column - 1 }
    }
}

const getPointValue = (map: number[][], point: Point) => {
    if (point.line >= 0 && point.line < map.length && point.column >= 0 && point.column < map[0].length) {
        return map[point.line][point.column]
    }
    return Infinity
}

const getLeftRight = (routePoint: RoutePoint): RoutePoint[] => {
    switch (routePoint.dir) {
        case Direction.North, Direction.South:
            return [{ point: { line: routePoint.point.line, column: routePoint.point.column - 1 }, dir: Direction.West }, { point: { line: routePoint.point.line, column: routePoint.point.column + 1 }, dir: Direction.East }]
        default:
            return [{ point: { line: routePoint.point.line - 1, column: routePoint.point.column }, dir: Direction.North }, { point: { line: routePoint.point.line + 1, column: routePoint.point.column }, dir: Direction.South }]
    }
}


const dijkstra = (map: number[][], sourcePoint: Node) => {
    const queue: Node[] = [sourcePoint]
    const processed: string[] = []
    const distance = new Map<string, number>()
    const previous = new Map<string, string>()
    distance.set(JSON.stringify(sourcePoint), getPointValue(map, sourcePoint.point))
    previous.set(JSON.stringify(sourcePoint), JSON.stringify("start"))
    distance.set(JSON.stringify("start"), 0)

    while (queue.length !== 0) {
        const initialNode = queue.shift()
        if (!initialNode) {
            break // never hit
        }
        if (processed.find(val => val === JSON.stringify(initialNode))) {
            continue
        }

        if (initialNode.point.line < 0 || initialNode.point.line >= map.length || initialNode.point.column < 0 || initialNode.point.column >= map[0].length) {
            continue
        }
        let previousNode: Node = initialNode
        let nextNode: Node = initialNode
        for (let step = 0; step < 3; step++) {
            if (getPointValue(map, nextNode.point) === Infinity) {
                break
            }
            const currentDistance = distance.get(JSON.stringify(nextNode))
            console.log(currentDistance)
            const previousDistance = distance.get(previous.get(JSON.stringify(nextNode)) ?? '')
            console.log(previousDistance)
            if (previousDistance === undefined) {
                continue
            }
            console.log(getPointValue(map, nextNode.point))
            if (!currentDistance) {
                previous.set(JSON.stringify(nextNode), JSON.stringify(previousNode))
                const newDistance = (previousDistance) + getPointValue(map, nextNode.point)
                console.log(newDistance)
                distance.set(JSON.stringify(nextNode), newDistance)
            } else {
                if (currentDistance > (previousDistance) + getPointValue(map, nextNode.point)) {
                    const newDistance = (previousDistance) + getPointValue(map, nextNode.point)
                    console.log(newDistance)
                    distance.set(JSON.stringify(nextNode), newDistance)
                    previous.set(JSON.stringify(nextNode), JSON.stringify(previousNode))
                }
            }
            console.log('---')

            const [left, right] = getLeftRight(nextNode)
            queue.push(left, right)
            if (!previous.has(JSON.stringify(left))) {
                previous.set(JSON.stringify(left), JSON.stringify(nextNode))
                distance.set(JSON.stringify(left), Infinity)
            }
            if (!previous.has(JSON.stringify(right))) {
                previous.set(JSON.stringify(right), JSON.stringify(nextNode))
                distance.set(JSON.stringify(right), Infinity)
            }
            previousNode = nextNode
            processed.push(JSON.stringify(nextNode))
            nextNode = { ...nextNode, point: incrementPoint(nextNode.point, nextNode.dir) }
            if (!previous.has(JSON.stringify(nextNode))) {
                previous.set(JSON.stringify(nextNode), JSON.stringify(previousNode))
                distance.set(JSON.stringify(nextNode), Infinity)
            }

        }
    }
    console.log(distance.get(JSON.stringify({ point: { line: 12, column: 12 }, dir: 0 })))
    console.log(distance.get(JSON.stringify({ point: { line: 12, column: 12 }, dir: 1 })))
    console.log(distance.get(JSON.stringify({ point: { line: 12, column: 12 }, dir: 2 })))
    console.log(distance.get(JSON.stringify({ point: { line: 12, column: 12 }, dir: 3 })))
}



const dijkstra = (map: number[][], sourcePoint: Node) => {
    const allDirections = [Direction.North, Direction.East, Direction.South, Direction.West]
    const distance = new Map<string, number>()
    const previous = new Map<string, Node | undefined>()

    for (let i = 0; i < map.length; i++) {
        for (let j = 0; j < map[0].length; j++) {
            const point: Point = { line: i, column: j }
            distance.set(JSON.stringify(point), Infinity)
            for (const dir of allDirections) {
                previous.set(JSON.stringify({ point, dir }), undefined)
            }
        }
    }

    const processed: Node[] = []
    const startingPoint = { line: 0, column: 0 }
    const startingNode = { point: startingPoint, dir: -1 }
    distance.set(JSON.stringify(startingPoint), 0)
    const queue = [startingNode]
    let i = 0
    while (queue.length !== 0) {
        const node = queue.shift()
        if (!node) {
            break // never hit
        }

        if (node.point.line < 0 || node.point.line >= map.length || node.point.column < 0 || node.point.column >= map[0].length) {
            continue
        }

        if (processed.find(val => val.dir === node.dir && val.point.line === node.point.line && val.point.column === node.point.column)) {
            continue
        }

        let directions: Direction[]
        if (node.dir === -1) {
            // start node
            directions = allDirections
        } else {
            directions = getLeftRightDirections(node.dir)
        }

        for (const dir of directions) {
            let previousNode = node
            let currentNode = { point: incrementPoint(previousNode.point, dir), dir }


            for (let s = 0; s < 3; s++) {
                const distToPreviousNode = distance.get(JSON.stringify(previousNode.point)) ?? Infinity
                const altDist = distToPreviousNode + getPointValue(map, currentNode.point)

                const distToCurrentNode = distance.get(JSON.stringify(currentNode.point)) ?? Infinity
                if (altDist < distToCurrentNode) {
                    distance.set(JSON.stringify(currentNode.point), altDist)
                    previous.set(JSON.stringify(currentNode), previousNode)
                }

                queue.push(currentNode)
                previousNode = currentNode
                currentNode = { point: incrementPoint(previousNode.point, dir), dir }
            }

        }
        processed.push(node)
        i++
    }
    for (let [key, value] of distance.entries()) {
        console.log(key, value)
    }
}