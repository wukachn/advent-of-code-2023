import readFile from "../../util/readFile"
import PriorityQueue from "ts-priority-queue"

enum Direction {
    North,
    East,
    South,
    West
}

interface Point {
    line: number,
    column: number
}

interface Node {
    point: Point,
    dir: Direction,
    steps: number
}

const incrementPoint = (point: Point, dir: Direction): Point => {
    switch (dir) {
        case Direction.North:
            return { line: point.line - 1, column: point.column }
        case Direction.East:
            return { line: point.line, column: point.column + 1 }
        case Direction.South:
            return { line: point.line + 1, column: point.column }
        case Direction.West:
            return { line: point.line, column: point.column - 1 }
    }
}

const getLeftRightDirections = (dir: Direction): Direction[] => {
    switch (dir) {
        case Direction.North:
        case Direction.South:
            return [Direction.East, Direction.West]
        default:
            return [Direction.North, Direction.South]
    }
}

const tooStraight = (previous: Map<string, Node | undefined>, currentNode: Node | undefined, previousNode: Node | undefined): boolean => {
    let count = 1;
    while (currentNode && previousNode && currentNode.dir === previousNode.dir) {
        const temp = previous.get(JSON.stringify(previousNode))
        currentNode = previousNode;
        previousNode = temp
        count++;
    }
    return count > 3
}

const getPointValue = (map: number[][], point: Point) => {
    if (point.line >= 0 && point.line < map.length && point.column >= 0 && point.column < map[0].length) {
        return map[point.line][point.column]
    }
    return Infinity
}

const dijkstra = (map: number[][]) => {
    const allDirections = [Direction.North, Direction.East, Direction.South, Direction.West]
    const distance = new Map<string, number>()
    const previous = new Map<string, Node | undefined>()

    for (let i = 0; i < map.length; i++) {
        for (let j = 0; j < map[0].length; j++) {
            const point: Point = { line: i, column: j }
            for (const dir of allDirections) {
                for (let s = 1; s <= 3; s++) {
                    distance.set(JSON.stringify({ point, dir, steps: s }), Infinity)
                    previous.set(JSON.stringify({ point, dir, steps: s }), undefined)
                }
            }
        }
    }

    const processed: Node[] = []
    const startingPoint = { line: 0, column: 0 }
    const startingNode = { point: startingPoint, dir: -1, steps: 0 }
    distance.set(JSON.stringify(startingNode), 0)
    let i = 0
    const queue = new PriorityQueue({ comparator: (a, b) => (distance.get(JSON.stringify(a)) ?? Infinity) - (distance.get(JSON.stringify(b)) ?? Infinity) })
    queue.queue(startingNode)
    while (queue.length !== 0) {
        const node = queue.dequeue() as { point: Point, dir: number, steps: number }
        if (!node) {
            break // never hit
        }

        if (node.point.line === map.length - 1 && node.point.column === map[0].length - 1) {
            return distance.get(JSON.stringify(node))
        }

        if (processed.find(val => val.dir === node.dir && val.point.line === node.point.line && val.point.column === node.point.column && val.steps === node.steps)) {
            continue
        }

        let directions: Direction[]
        if (node.dir === -1) {
            // start node
            directions = allDirections
        } else {
            directions = getLeftRightDirections(node.dir)
        }

        for (const dir of directions) {
            let previousNode = node
            let currentNode = { point: incrementPoint(node.point, dir), dir, steps: 1 }

            for (let s = 0; s < 3; s++) {
                if (currentNode.point.line < 0 || currentNode.point.line >= map.length || currentNode.point.column < 0 || currentNode.point.column >= map[0].length) {
                    break
                }

                if (currentNode.steps > 3) {
                    break
                }

                const distToPreviousNode = distance.get(JSON.stringify(previousNode)) ?? Infinity
                const altDist = distToPreviousNode + getPointValue(map, currentNode.point)

                const distToCurrentNode = distance.get(JSON.stringify(currentNode)) ?? Infinity

                if (altDist < distToCurrentNode /*&& !tooStraight(previous, currentNode, previousNode)*/) {

                    if (previousNode.dir === currentNode.dir) {
                        if (currentNode.steps <= 3) {
                            distance.set(JSON.stringify(currentNode), altDist)
                            previous.set(JSON.stringify(currentNode), previousNode)
                        }
                    } else {
                        distance.set(JSON.stringify({ ...currentNode, steps: 1 }), altDist)
                        previous.set(JSON.stringify({ ...currentNode, steps: 1 }), previousNode)
                    }
                }

                queue.queue(currentNode)
                previousNode = currentNode
                currentNode = { point: incrementPoint(previousNode.point, dir), dir, steps: previousNode.steps + 1 }

            }
        }

        processed.push(node)
        i++
    }

    for (let [key, value] of distance.entries()) {
        const abc: Node = JSON.parse(key)
        if (abc.point.column === 12 && abc.point.line === 12) {
            console.log(key, value)
        }
    }
    /*
        const toChar = (dir: number) => {
            switch (dir) {
                case Direction.North:
                    return '^'
                case Direction.East:
                    return '>'
                case Direction.South:
                    return 'v'
                case Direction.West:
                    return '<'
                default:
                    return 'X'
            }
        }
    
        const newMap = map.map(line => line.map(String))
        let total = getPointValue(map, { line: 12, column: 12 })
        let a: Node | undefined = { point: { line: 12, column: 12 }, dir: 2, }
        console.log(previous.get(JSON.stringify(a)))
        while (a !== undefined) {
            a = previous.get(JSON.stringify(a))
            console.log(a)
            if (a !== undefined) {
                newMap[a.point.line][a.point.column] = toChar(a.dir)
                total += getPointValue(map, a.point)
            }
        }
    
        console.log(newMap.map(line => line.join('')).join('\n'))
        console.log(total - getPointValue(map, { line: 0, column: 0 }))
    
        total = getPointValue(map, { line: 12, column: 12 })
        a = { point: { line: 12, column: 12 }, dir: 1 }
        console.log(previous.get(JSON.stringify(a)))
        while (a !== undefined) {
            a = previous.get(JSON.stringify(a))
    
            if (a !== undefined) {
                newMap[a.point.line][a.point.column] = toChar(a.dir)
                total += getPointValue(map, a.point)
            }
        }
        console.log(total - getPointValue(map, { line: 0, column: 0 }))*/
}

const run = async () => {
    const puzzleInput: string = await readFile('./input.txt')
    const map: number[][] = puzzleInput.split('\n').map(line => line.split('').map(Number))
    const a = dijkstra(map)
    console.log(a)
}

run()